/***********************************************************************************************//**
 *  Container and manager of activities known or generated by a single Agent.
 *  @class      ActivityHandler
 *  @authors    Carles Araguz (CA), carles.araguz@upc.edu
 *  @date       2018-sep-26
 *  @version    0.1
 *  @copyright  This file is part of a project developed by Nano-Satellite and Payload Laboratory
 *              (NanoSat Lab) at Technical University of Catalonia - UPC BarcelonaTech.
 **************************************************************************************************/

#include "ActivityHandler.hpp"
#include "Agent.hpp"

CREATE_LOGGER(ActivityHandler)

ActivityHandler::ActivityHandler(Agent* aptr)
    : m_agent(aptr)
    , m_activity_count(0)
    , m_update_view(false)
{
    m_self_view.setOwnActivityList(&m_activities_own);
    m_self_view.setOthersActivityList(&m_activities_others);
    m_self_view.display(ActivityDisplayType::NONE);
}

void ActivityHandler::setAgentId(std::string aid)
{
    m_agent_id = aid;
    m_self_view.setAgentId(aid);
}

std::shared_ptr<Activity> ActivityHandler::getNextActivity(double t) const
{
    std::shared_ptr<Activity> retval(nullptr);
    /*  NB: This function assumes that:
     *  - Activities are sorted by start time.
     *  - Start and end times of activities for an agent do not overlap.
     **/
    for(auto& ac : m_activities_own) {
        if(ac->getStartTime() > t) {
            retval = ac;
            break;
        }
    }
    return retval;
}

std::shared_ptr<Activity> ActivityHandler::getCurrentActivity(void) const
{
    std::shared_ptr<Activity> retval(nullptr);
    double t = VirtualTime::now();
    /*  NB: This function assumes that:
     *  - Activities are sorted by start time.
     *  - Start and end times of activities for an agent do not overlap.
     **/
    for(auto& ac : m_activities_own) {
        if(ac->getStartTime() <= t && ac->getEndTime() >= t) {
            retval = ac;
            break;
        }
    }
    return retval;
}

std::shared_ptr<Activity> ActivityHandler::getLastActivity(void) const
{
    if(m_activities_own.size() > 0) {
        return m_activities_own.back();
    } else {
        return nullptr;
    }
}

unsigned int ActivityHandler::count(std::string aid) const
{
    if(aid == m_agent_id) {
        return m_activities_own.size();
    } else {
        auto it = m_activities_others.find(aid);
        if(it != m_activities_others.end()) {
            return m_activities_others.at(aid).size();
        } else {
            return 0;
        }
    }
}

unsigned int ActivityHandler::pending(std::string aid) const
{
    int count = 0;
    if(aid == m_agent_id) {
        for(auto& a : m_activities_own) {
            if(a->getEndTime() > VirtualTime::now()) {       /* Ends in the future. */
                count++;
            }
        }
        return count;
    } else {
        auto it = m_activities_others.find(aid);
        if(it != m_activities_others.end()) {
            for(auto& a : m_activities_others.at(aid)) {
                if(a->getEndTime() > VirtualTime::now()) {   /* Ends in the future. */
                    count++;
                }
            }
            return count;
        } else {
            return 0;
        }
    }
}


std::shared_ptr<Activity> ActivityHandler::createOwnedActivity(
    const std::map<double, sf::Vector2f>& a_pos,
    const std::vector<ActivityCell>& a_cells)
{
    auto a = std::make_shared<Activity>(m_agent_id);
    a->setTrajectory(a_pos, a_cells);
    return a;
}

void ActivityHandler::add(std::shared_ptr<Activity> pa)
{
    if(pa->isOwner(m_agent_id)) {
        /* It's owned: */
        pa->setId(m_activity_count++);
        m_activities_own.push_back(pa);
        std::sort(m_activities_own.begin(), m_activities_own.end());
        Log::dbg << "Agent " << m_agent_id << " added a new activity: " << *pa << "\n";
    }
    if(m_update_view) {
        m_self_view.update();
    }
}

const sf::Drawable& ActivityHandler::getView(void) const
{
    return m_self_view;
}

void ActivityHandler::autoUpdateView(bool auto_update)
{
    m_update_view = auto_update;
}

void ActivityHandler::displayInView(ActivityDisplayType adt, std::vector<std::pair<std::string, unsigned int> > filter)
{
    m_self_view.display(adt, filter);
}
